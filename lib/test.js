// Generated by CoffeeScript 1.8.0
(function() {
  var async, createKarmaFileList, events, fs, log, path, phantom, run, runBrowser, runKarma, runPhantom, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  log = require('./log');

  utils = require('./utils');

  events = require('./events');

  phantom = require('./phantom');

  async = require('async');

  run = function(apps, options) {
    var runTests;
    switch (options.runner) {
      case "phantom":
        runTests = phantom.run ? runPhantom : runBrowser;
        break;
      case "karma":
        runTests = runKarma;
        break;
      case "browser":
        runTests = runBrowser;
        break;
      default:
        log.errorAndExit("Invalid or unset test runner value: <yellow>" + options.runner + "</yellow>");
    }
    return runTests(apps, options);
  };

  runBrowser = function(apps, options, done) {
    var app, open, q, tasks, testFile, testName, _i, _len;
    open = require("open");
    tasks = {};
    for (_i = 0, _len = apps.length; _i < _len; _i++) {
      app = apps[_i];
      testName = app.name;
      testFile = app.getTestPackage().getTestIndexFile();
      tasks[testName] = (function(testFile) {
        return function(done) {
          open(testFile);
          return done();
        };
      })(testFile);
    }
    if (options.singleRun) {
      return async.series(tasks);
    } else {
      q = async.queue((function(task, callback) {
        return task(callback);
      }), 1);
      return events.on("watch", function(app, pkg, file) {
        return q.push(tasks[app.name]);
      });
    }
  };

  runPhantom = function(apps, options, done) {
    var app, q, tasks, testFile, testName, testPort, _i, _len;
    options.output || (options.output = "passOrFail");
    tasks = {};
    for (_i = 0, _len = apps.length; _i < _len; _i++) {
      app = apps[_i];
      testName = app.name;
      testFile = app.getTestPackage().getTestIndexFile();
      testPort = 12300 + Object.keys(tasks).length;
      tasks[testName] = (function(testName, testFile, testPort) {
        return function(done) {
          log("Testing application targets: <green>" + testName + "</green>");
          return phantom.run(testFile, options, function(results) {
            if (results.error) {
              log.error(results.error);
            }
            return done(null, results);
          }, testPort);
        };
      })(testName, testFile, testPort);
    }
    if (options.singleRun) {
      return async.series(tasks, function(err, results) {
        var exitCode, name, result;
        exitCode = 0;
        for (name in results) {
          result = results[name];
          exitCode += result.failed && result.failed || 0;
          exitCode += result.error && 1 || 0;
        }
        return process.exit(exitCode);
      });
    } else {
      q = async.queue((function(task, callback) {
        return task(callback);
      }), 1);
      return events.on("watch", function(app, pkg, file) {
        return q.push(tasks[app.name]);
      });
    }
  };

  runKarma = function(apps, options) {
    var app, karma, q, tasks, testConfig, _i, _len;
    if (options == null) {
      options = {};
    }
    karma = require('karma').server;
    tasks = {};
    options.reporters || (options.reporters = 'progress');
    options.frameworks || (options.frameworks = 'jasmine');
    options.browsers || (options.browsers = 'PhantomJS');
    options.reporters = Array.isArray(options.reporters) || options.reporters.split(/[ ,]+/);
    options.frameworks = Array.isArray(options.frameworks) || options.frameworks.split(/[ ,]+/);
    options.browsers = Array.isArray(options.browsers) || options.browsers.split(/[ ,]+/);
    for (_i = 0, _len = apps.length; _i < _len; _i++) {
      app = apps[_i];
      testConfig = {
        singleRun: true,
        autoWatch: false,
        basePath: options.basePath,
        logLevel: options.logLevel || 'error',
        reporters: options.reporters,
        frameworks: options.frameworks,
        browsers: options.browsers,
        preprocessors: options.preprocessors || null
      };
      testConfig.files = createKarmaFileList(app);
      testConfig.coverageReporter = options.coverageReporter || null;
      console.log(testConfig);
      if (__indexOf.call(testConfig.reporters, 'junit') >= 0) {
        testConfig.junitReporter = {
          outputFile: app.name + '-test-results.xml',
          suite: app.name
        };
      }
      tasks[app.name] = (function(app, testConfig) {
        return function(done) {
          var callback;
          log("Testing application targets: <green>" + app.name + "</green>");
          callback = function(exitCode) {
            return done(null, {
              failed: exitCode
            });
          };
          return karma.start(testConfig, callback);
        };
      })(app, testConfig);
    }
    if (options.singleRun) {
      return async.series(tasks, function(err, results) {
        var exitCode, name, result;
        exitCode = 0;
        for (name in results) {
          result = results[name];
          exitCode += result.failed && result.failed || 0;
          exitCode += result.error && 1 || 0;
        }
        return process.exit(exitCode);
      });
    } else {
      q = async.queue((function(task, callback) {
        return task(callback);
      }), 1);
      return events.on("watch", function(app, pkg, file) {
        return q.push(tasks[app.name]);
      });
    }
  };

  createKarmaFileList = function(app) {
    var files, target, _i, _len, _ref;
    files = [];
    _ref = app.getTestPackage().getAllTestTargets(false);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      target = _ref[_i];
      files.push(target.path);
    }
    return files;
  };

  module.exports.run = run;

  module.exports.phantom = phantom;

}).call(this);
